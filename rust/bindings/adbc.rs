/* automatically generated by rust-bindgen 0.69.1 */

pub const ADBC_STATUS_OK: u32 = 0;
pub const ADBC_STATUS_UNKNOWN: u32 = 1;
pub const ADBC_STATUS_NOT_IMPLEMENTED: u32 = 2;
pub const ADBC_STATUS_NOT_FOUND: u32 = 3;
pub const ADBC_STATUS_ALREADY_EXISTS: u32 = 4;
pub const ADBC_STATUS_INVALID_ARGUMENT: u32 = 5;
pub const ADBC_STATUS_INVALID_STATE: u32 = 6;
pub const ADBC_STATUS_INVALID_DATA: u32 = 7;
pub const ADBC_STATUS_INTEGRITY: u32 = 8;
pub const ADBC_STATUS_INTERNAL: u32 = 9;
pub const ADBC_STATUS_IO: u32 = 10;
pub const ADBC_STATUS_CANCELLED: u32 = 11;
pub const ADBC_STATUS_TIMEOUT: u32 = 12;
pub const ADBC_STATUS_UNAUTHENTICATED: u32 = 13;
pub const ADBC_STATUS_UNAUTHORIZED: u32 = 14;
pub const ADBC_ERROR_VENDOR_CODE_PRIVATE_DATA: i32 = -2147483648;
pub const ADBC_VERSION_1_0_0: u32 = 1000000;
pub const ADBC_VERSION_1_1_0: u32 = 1001000;
pub const ADBC_OPTION_VALUE_ENABLED: &[u8; 5] = b"true\0";
pub const ADBC_OPTION_VALUE_DISABLED: &[u8; 6] = b"false\0";
pub const ADBC_OPTION_URI: &[u8; 4] = b"uri\0";
pub const ADBC_OPTION_USERNAME: &[u8; 9] = b"username\0";
pub const ADBC_OPTION_PASSWORD: &[u8; 9] = b"password\0";
pub const ADBC_INFO_VENDOR_NAME: u32 = 0;
pub const ADBC_INFO_VENDOR_VERSION: u32 = 1;
pub const ADBC_INFO_VENDOR_ARROW_VERSION: u32 = 2;
pub const ADBC_INFO_DRIVER_NAME: u32 = 100;
pub const ADBC_INFO_DRIVER_VERSION: u32 = 101;
pub const ADBC_INFO_DRIVER_ARROW_VERSION: u32 = 102;
pub const ADBC_INFO_DRIVER_ADBC_VERSION: u32 = 103;
pub const ADBC_OBJECT_DEPTH_ALL: u32 = 0;
pub const ADBC_OBJECT_DEPTH_CATALOGS: u32 = 1;
pub const ADBC_OBJECT_DEPTH_DB_SCHEMAS: u32 = 2;
pub const ADBC_OBJECT_DEPTH_TABLES: u32 = 3;
pub const ADBC_OBJECT_DEPTH_COLUMNS: u32 = 0;
pub const ADBC_STATISTIC_AVERAGE_BYTE_WIDTH_KEY: u32 = 0;
pub const ADBC_STATISTIC_AVERAGE_BYTE_WIDTH_NAME: &[u8; 26] = b"adbc.statistic.byte_width\0";
pub const ADBC_STATISTIC_DISTINCT_COUNT_KEY: u32 = 1;
pub const ADBC_STATISTIC_DISTINCT_COUNT_NAME: &[u8; 30] = b"adbc.statistic.distinct_count\0";
pub const ADBC_STATISTIC_MAX_BYTE_WIDTH_KEY: u32 = 2;
pub const ADBC_STATISTIC_MAX_BYTE_WIDTH_NAME: &[u8; 26] = b"adbc.statistic.byte_width\0";
pub const ADBC_STATISTIC_MAX_VALUE_KEY: u32 = 3;
pub const ADBC_STATISTIC_MAX_VALUE_NAME: &[u8; 26] = b"adbc.statistic.byte_width\0";
pub const ADBC_STATISTIC_MIN_VALUE_KEY: u32 = 4;
pub const ADBC_STATISTIC_MIN_VALUE_NAME: &[u8; 26] = b"adbc.statistic.byte_width\0";
pub const ADBC_STATISTIC_NULL_COUNT_KEY: u32 = 5;
pub const ADBC_STATISTIC_NULL_COUNT_NAME: &[u8; 26] = b"adbc.statistic.null_count\0";
pub const ADBC_STATISTIC_ROW_COUNT_KEY: u32 = 6;
pub const ADBC_STATISTIC_ROW_COUNT_NAME: &[u8; 25] = b"adbc.statistic.row_count\0";
pub const ADBC_CONNECTION_OPTION_AUTOCOMMIT: &[u8; 27] = b"adbc.connection.autocommit\0";
pub const ADBC_CONNECTION_OPTION_READ_ONLY: &[u8; 25] = b"adbc.connection.readonly\0";
pub const ADBC_CONNECTION_OPTION_CURRENT_CATALOG: &[u8; 24] = b"adbc.connection.catalog\0";
pub const ADBC_CONNECTION_OPTION_CURRENT_DB_SCHEMA: &[u8; 26] = b"adbc.connection.db_schema\0";
pub const ADBC_STATEMENT_OPTION_INCREMENTAL: &[u8; 32] = b"adbc.statement.exec.incremental\0";
pub const ADBC_STATEMENT_OPTION_PROGRESS: &[u8; 29] = b"adbc.statement.exec.progress\0";
pub const ADBC_STATEMENT_OPTION_MAX_PROGRESS: &[u8; 33] = b"adbc.statement.exec.max_progress\0";
pub const ADBC_CONNECTION_OPTION_ISOLATION_LEVEL: &[u8; 44] = b"adbc.connection.transaction.isolation_level\0";
pub const ADBC_OPTION_ISOLATION_LEVEL_DEFAULT: &[u8; 46] = b"adbc.connection.transaction.isolation.default\0";
pub const ADBC_OPTION_ISOLATION_LEVEL_READ_UNCOMMITTED: &[u8; 55] = b"adbc.connection.transaction.isolation.read_uncommitted\0";
pub const ADBC_OPTION_ISOLATION_LEVEL_READ_COMMITTED: &[u8; 53] = b"adbc.connection.transaction.isolation.read_committed\0";
pub const ADBC_OPTION_ISOLATION_LEVEL_REPEATABLE_READ: &[u8; 54] = b"adbc.connection.transaction.isolation.repeatable_read\0";
pub const ADBC_OPTION_ISOLATION_LEVEL_SNAPSHOT: &[u8; 47] = b"adbc.connection.transaction.isolation.snapshot\0";
pub const ADBC_OPTION_ISOLATION_LEVEL_SERIALIZABLE: &[u8; 51] = b"adbc.connection.transaction.isolation.serializable\0";
pub const ADBC_OPTION_ISOLATION_LEVEL_LINEARIZABLE: &[u8; 51] = b"adbc.connection.transaction.isolation.linearizable\0";
pub const ADBC_INGEST_OPTION_TARGET_TABLE: &[u8; 25] = b"adbc.ingest.target_table\0";
pub const ADBC_INGEST_OPTION_MODE: &[u8; 17] = b"adbc.ingest.mode\0";
pub const ADBC_INGEST_OPTION_MODE_CREATE: &[u8; 24] = b"adbc.ingest.mode.create\0";
pub const ADBC_INGEST_OPTION_MODE_APPEND: &[u8; 24] = b"adbc.ingest.mode.append\0";
pub const ADBC_INGEST_OPTION_MODE_REPLACE: &[u8; 25] = b"adbc.ingest.mode.replace\0";
pub const ADBC_INGEST_OPTION_MODE_CREATE_APPEND: &[u8; 31] = b"adbc.ingest.mode.create_append\0";
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArrowSchema {
    pub format: *const ::std::os::raw::c_char,
    pub name: *const ::std::os::raw::c_char,
    pub metadata: *const ::std::os::raw::c_char,
    pub flags: i64,
    pub n_children: i64,
    pub children: *mut *mut ArrowSchema,
    pub dictionary: *mut ArrowSchema,
    pub release: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ArrowSchema)>,
    pub private_data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_ArrowSchema() {
    const UNINIT: ::std::mem::MaybeUninit<ArrowSchema> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ArrowSchema>(),
        72usize,
        concat!("Size of: ", stringify!(ArrowSchema)),
    );
    assert_eq!(
        ::std::mem::align_of::<ArrowSchema>(),
        8usize,
        concat!("Alignment of ", stringify!(ArrowSchema)),
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(ArrowSchema), "::", stringify!(format)),
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        8usize,
        concat!("Offset of field: ", stringify!(ArrowSchema), "::", stringify!(name)),
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).metadata) as usize - ptr as usize },
        16usize,
        concat!("Offset of field: ", stringify!(ArrowSchema), "::", stringify!(metadata)),
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        24usize,
        concat!("Offset of field: ", stringify!(ArrowSchema), "::", stringify!(flags)),
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_children) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrowSchema),
            "::",
            stringify!(n_children),
        ),
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).children) as usize - ptr as usize },
        40usize,
        concat!("Offset of field: ", stringify!(ArrowSchema), "::", stringify!(children)),
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dictionary) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrowSchema),
            "::",
            stringify!(dictionary),
        ),
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).release) as usize - ptr as usize },
        56usize,
        concat!("Offset of field: ", stringify!(ArrowSchema), "::", stringify!(release)),
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).private_data) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrowSchema),
            "::",
            stringify!(private_data),
        ),
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArrowArray {
    pub length: i64,
    pub null_count: i64,
    pub offset: i64,
    pub n_buffers: i64,
    pub n_children: i64,
    pub buffers: *mut *const ::std::os::raw::c_void,
    pub children: *mut *mut ArrowArray,
    pub dictionary: *mut ArrowArray,
    pub release: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ArrowArray)>,
    pub private_data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_ArrowArray() {
    const UNINIT: ::std::mem::MaybeUninit<ArrowArray> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ArrowArray>(),
        80usize,
        concat!("Size of: ", stringify!(ArrowArray)),
    );
    assert_eq!(
        ::std::mem::align_of::<ArrowArray>(),
        8usize,
        concat!("Alignment of ", stringify!(ArrowArray)),
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(ArrowArray), "::", stringify!(length)),
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).null_count) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrowArray),
            "::",
            stringify!(null_count),
        ),
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        16usize,
        concat!("Offset of field: ", stringify!(ArrowArray), "::", stringify!(offset)),
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_buffers) as usize - ptr as usize },
        24usize,
        concat!("Offset of field: ", stringify!(ArrowArray), "::", stringify!(n_buffers)),
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_children) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrowArray),
            "::",
            stringify!(n_children),
        ),
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffers) as usize - ptr as usize },
        40usize,
        concat!("Offset of field: ", stringify!(ArrowArray), "::", stringify!(buffers)),
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).children) as usize - ptr as usize },
        48usize,
        concat!("Offset of field: ", stringify!(ArrowArray), "::", stringify!(children)),
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dictionary) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrowArray),
            "::",
            stringify!(dictionary),
        ),
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).release) as usize - ptr as usize },
        64usize,
        concat!("Offset of field: ", stringify!(ArrowArray), "::", stringify!(release)),
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).private_data) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrowArray),
            "::",
            stringify!(private_data),
        ),
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ArrowArrayStream {
    pub get_schema: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ArrowArrayStream,
            out: *mut ArrowSchema,
        ) -> ::std::os::raw::c_int,
    >,
    pub get_next: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ArrowArrayStream,
            out: *mut ArrowArray,
        ) -> ::std::os::raw::c_int,
    >,
    pub get_last_error: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ArrowArrayStream,
        ) -> *const ::std::os::raw::c_char,
    >,
    pub release: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut ArrowArrayStream),
    >,
    pub private_data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_ArrowArrayStream() {
    const UNINIT: ::std::mem::MaybeUninit<ArrowArrayStream> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ArrowArrayStream>(),
        40usize,
        concat!("Size of: ", stringify!(ArrowArrayStream)),
    );
    assert_eq!(
        ::std::mem::align_of::<ArrowArrayStream>(),
        8usize,
        concat!("Alignment of ", stringify!(ArrowArrayStream)),
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_schema) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrowArrayStream),
            "::",
            stringify!(get_schema),
        ),
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_next) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrowArrayStream),
            "::",
            stringify!(get_next),
        ),
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_last_error) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrowArrayStream),
            "::",
            stringify!(get_last_error),
        ),
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).release) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrowArrayStream),
            "::",
            stringify!(release),
        ),
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).private_data) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ArrowArrayStream),
            "::",
            stringify!(private_data),
        ),
    );
}
///Error codes for operations that may fail.
pub type AdbcStatusCode = u8;
/**A detailed error message for an operation.

 The caller must zero-initialize this struct (clarified in ADBC 1.1.0).

 The structure was extended in ADBC 1.1.0. Drivers and clients using ADBC
 1.0.0 will not have the private_data or private_driver fields. Drivers
 should read/write these fields if and only if vendor_code is equal to
 ADBC_ERROR_VENDOR_CODE_PRIVATE_DATA. Clients are required to initialize
 this struct to avoid the possibility of uninitialized values confusing the
 driver.*/
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AdbcError {
    ///The error message.
    pub message: *mut ::std::os::raw::c_char,
    ///A vendor-specific error code, if applicable.
    pub vendor_code: i32,
    /**A SQLSTATE error code, if provided, as defined by the
 SQL:2003 standard. If not set, it should be set to
 "*/
    pub sqlstate: [::std::os::raw::c_char; 5usize],
    /**Release the contained error.

 Unlike other structures, this is an embedded callback to make it
 easier for the driver manager and driver to cooperate.*/
    pub release: ::std::option::Option<unsafe extern "C" fn(error: *mut AdbcError)>,
    /**Opaque implementation-defined state.

 This field may not be used unless vendor_code is
 ADBC_ERROR_VENDOR_CODE_PRIVATE_DATA. If present, this field is NULLPTR
 iff the error is unintialized/freed.

 > Available since: ADBC API revision 1.1.0*/
    pub private_data: *mut ::std::os::raw::c_void,
    /**The associated driver (used by the driver manager to help
 track state).

 This field may not be used unless vendor_code is
 ADBC_ERROR_VENDOR_CODE_PRIVATE_DATA.

 > Available since: ADBC API revision 1.1.0*/
    pub private_driver: *mut AdbcDriver,
}
#[test]
fn bindgen_test_layout_AdbcError() {
    const UNINIT: ::std::mem::MaybeUninit<AdbcError> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AdbcError>(),
        48usize,
        concat!("Size of: ", stringify!(AdbcError)),
    );
    assert_eq!(
        ::std::mem::align_of::<AdbcError>(),
        8usize,
        concat!("Alignment of ", stringify!(AdbcError)),
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).message) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(AdbcError), "::", stringify!(message)),
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vendor_code) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcError),
            "::",
            stringify!(vendor_code),
        ),
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sqlstate) as usize - ptr as usize },
        12usize,
        concat!("Offset of field: ", stringify!(AdbcError), "::", stringify!(sqlstate)),
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).release) as usize - ptr as usize },
        24usize,
        concat!("Offset of field: ", stringify!(AdbcError), "::", stringify!(release)),
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).private_data) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcError),
            "::",
            stringify!(private_data),
        ),
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).private_driver) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcError),
            "::",
            stringify!(private_driver),
        ),
    );
}
/**Extra key-value metadata for an error.

 The fields here are owned by the driver and should not be freed. The
 fields here are invalidated when the release callback in AdbcError is
 called.

 > Available since: ADBC API revision 1.1.0*/
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AdbcErrorDetail {
    ///The metadata key.
    pub key: *const ::std::os::raw::c_char,
    ///The binary metadata value.
    pub value: *const u8,
    ///The length of the metadata value.
    pub value_length: usize,
}
#[test]
fn bindgen_test_layout_AdbcErrorDetail() {
    const UNINIT: ::std::mem::MaybeUninit<AdbcErrorDetail> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AdbcErrorDetail>(),
        24usize,
        concat!("Size of: ", stringify!(AdbcErrorDetail)),
    );
    assert_eq!(
        ::std::mem::align_of::<AdbcErrorDetail>(),
        8usize,
        concat!("Alignment of ", stringify!(AdbcErrorDetail)),
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(AdbcErrorDetail), "::", stringify!(key)),
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcErrorDetail),
            "::",
            stringify!(value),
        ),
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value_length) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcErrorDetail),
            "::",
            stringify!(value_length),
        ),
    );
}
extern "C" {
    /**Get the number of metadata values available in an error.

 > Available since: ADBC API revision 1.1.0*/
    pub fn AdbcErrorGetDetailCount(error: *const AdbcError) -> ::std::os::raw::c_int;
}
extern "C" {
    /**Get a metadata value in an error by index.

 If index is invalid, returns an AdbcErrorDetail initialized with NULL/0
 fields.

 > Available since: ADBC API revision 1.1.0*/
    pub fn AdbcErrorGetDetail(
        error: *const AdbcError,
        index: ::std::os::raw::c_int,
    ) -> AdbcErrorDetail;
}
extern "C" {
    /**Get an ADBC error from an ArrowArrayStream created by a driver.

 This allows retrieving error details and other metadata that would
 normally be suppressed by the Arrow C Stream Interface.

 The caller MUST NOT release the error; it is managed by the release
 callback in the stream itself.

 # Arguments

* `stream` (direction in) - The stream to query.
 * `status` (direction out) - The ADBC status code, or ADBC_STATUS_OK if there is no
 error. Not written to if the stream does not contain an ADBC error or
 if the pointer is NULL.
 # Returns

NULL if not supported.
 > Available since: ADBC API revision 1.1.0*/
    pub fn AdbcErrorFromArrayStream(
        stream: *mut ArrowArrayStream,
        status: *mut AdbcStatusCode,
    ) -> *const AdbcError;
}
/**An instance of a database.

 Must be kept alive as long as any connections exist.*/
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AdbcDatabase {
    /**Opaque implementation-defined state.
 This field is NULLPTR iff the connection is unintialized/freed.*/
    pub private_data: *mut ::std::os::raw::c_void,
    /**The associated driver (used by the driver manager to help
 track state).*/
    pub private_driver: *mut AdbcDriver,
}
#[test]
fn bindgen_test_layout_AdbcDatabase() {
    const UNINIT: ::std::mem::MaybeUninit<AdbcDatabase> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AdbcDatabase>(),
        16usize,
        concat!("Size of: ", stringify!(AdbcDatabase)),
    );
    assert_eq!(
        ::std::mem::align_of::<AdbcDatabase>(),
        8usize,
        concat!("Alignment of ", stringify!(AdbcDatabase)),
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).private_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDatabase),
            "::",
            stringify!(private_data),
        ),
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).private_driver) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDatabase),
            "::",
            stringify!(private_driver),
        ),
    );
}
/**An active database connection.

 Provides methods for query execution, managing prepared
 statements, using transactions, and so on.

 Connections are not required to be thread-safe, but they can be
 used from multiple threads so long as clients take care to
 serialize accesses to a connection.*/
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AdbcConnection {
    /**Opaque implementation-defined state.
 This field is NULLPTR iff the connection is unintialized/freed.*/
    pub private_data: *mut ::std::os::raw::c_void,
    /**The associated driver (used by the driver manager to help
 track state).*/
    pub private_driver: *mut AdbcDriver,
}
#[test]
fn bindgen_test_layout_AdbcConnection() {
    const UNINIT: ::std::mem::MaybeUninit<AdbcConnection> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AdbcConnection>(),
        16usize,
        concat!("Size of: ", stringify!(AdbcConnection)),
    );
    assert_eq!(
        ::std::mem::align_of::<AdbcConnection>(),
        8usize,
        concat!("Alignment of ", stringify!(AdbcConnection)),
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).private_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcConnection),
            "::",
            stringify!(private_data),
        ),
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).private_driver) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcConnection),
            "::",
            stringify!(private_driver),
        ),
    );
}
/**A container for all state needed to execute a database
 query, such as the query itself, parameters for prepared
 statements, driver parameters, etc.

 Statements may represent queries or prepared statements.

 Statements may be used multiple times and can be reconfigured
 (e.g. they can be reused to execute multiple different queries).
 However, executing a statement (and changing certain other state)
 will invalidate result sets obtained prior to that execution.

 Multiple statements may be created from a single connection.
 However, the driver may block or error if they are used
 concurrently (whether from a single thread or multiple threads).

 Statements are not required to be thread-safe, but they can be
 used from multiple threads so long as clients take care to
 serialize accesses to a statement.*/
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AdbcStatement {
    /**Opaque implementation-defined state.
 This field is NULLPTR iff the connection is unintialized/freed.*/
    pub private_data: *mut ::std::os::raw::c_void,
    /**The associated driver (used by the driver manager to help
 track state).*/
    pub private_driver: *mut AdbcDriver,
}
#[test]
fn bindgen_test_layout_AdbcStatement() {
    const UNINIT: ::std::mem::MaybeUninit<AdbcStatement> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AdbcStatement>(),
        16usize,
        concat!("Size of: ", stringify!(AdbcStatement)),
    );
    assert_eq!(
        ::std::mem::align_of::<AdbcStatement>(),
        8usize,
        concat!("Alignment of ", stringify!(AdbcStatement)),
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).private_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcStatement),
            "::",
            stringify!(private_data),
        ),
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).private_driver) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcStatement),
            "::",
            stringify!(private_driver),
        ),
    );
}
///The partitions of a distributed/partitioned result set.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AdbcPartitions {
    ///The number of partitions.
    pub num_partitions: usize,
    /**The partitions of the result set, where each entry (up to
 num_partitions entries) is an opaque identifier that can be
 passed to AdbcConnectionReadPartition.*/
    pub partitions: *mut *const u8,
    ///The length of each corresponding entry in partitions.
    pub partition_lengths: *const usize,
    /**Opaque implementation-defined state.
 This field is NULLPTR iff the connection is unintialized/freed.*/
    pub private_data: *mut ::std::os::raw::c_void,
    /**Release the contained partitions.

 Unlike other structures, this is an embedded callback to make it
 easier for the driver manager and driver to cooperate.*/
    pub release: ::std::option::Option<
        unsafe extern "C" fn(partitions: *mut AdbcPartitions),
    >,
}
#[test]
fn bindgen_test_layout_AdbcPartitions() {
    const UNINIT: ::std::mem::MaybeUninit<AdbcPartitions> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AdbcPartitions>(),
        40usize,
        concat!("Size of: ", stringify!(AdbcPartitions)),
    );
    assert_eq!(
        ::std::mem::align_of::<AdbcPartitions>(),
        8usize,
        concat!("Alignment of ", stringify!(AdbcPartitions)),
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_partitions) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcPartitions),
            "::",
            stringify!(num_partitions),
        ),
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).partitions) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcPartitions),
            "::",
            stringify!(partitions),
        ),
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).partition_lengths) as usize - ptr as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcPartitions),
            "::",
            stringify!(partition_lengths),
        ),
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).private_data) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcPartitions),
            "::",
            stringify!(private_data),
        ),
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).release) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcPartitions),
            "::",
            stringify!(release),
        ),
    );
}
/**An instance of an initialized database driver.

 This provides a common interface for vendor-specific driver
 initialization routines. Drivers should populate this struct, and
 applications can call ADBC functions through this struct, without
 worrying about multiple definitions of the same symbol.*/
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AdbcDriver {
    /**Opaque driver-defined state.
 This field is NULL if the driver is unintialized/freed (but
 it need not have a value even if the driver is initialized).*/
    pub private_data: *mut ::std::os::raw::c_void,
    /**Opaque driver manager-defined state.
 This field is NULL if the driver is unintialized/freed (but
 it need not have a value even if the driver is initialized).*/
    pub private_manager: *mut ::std::os::raw::c_void,
    /**Release the driver and perform any cleanup.

 This is an embedded callback to make it easier for the driver
 manager and driver to cooperate.*/
    pub release: ::std::option::Option<
        unsafe extern "C" fn(
            driver: *mut AdbcDriver,
            error: *mut AdbcError,
        ) -> AdbcStatusCode,
    >,
    pub DatabaseInit: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AdbcDatabase,
            arg2: *mut AdbcError,
        ) -> AdbcStatusCode,
    >,
    pub DatabaseNew: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AdbcDatabase,
            arg2: *mut AdbcError,
        ) -> AdbcStatusCode,
    >,
    pub DatabaseSetOption: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AdbcDatabase,
            arg2: *const ::std::os::raw::c_char,
            arg3: *const ::std::os::raw::c_char,
            arg4: *mut AdbcError,
        ) -> AdbcStatusCode,
    >,
    pub DatabaseRelease: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AdbcDatabase,
            arg2: *mut AdbcError,
        ) -> AdbcStatusCode,
    >,
    pub ConnectionCommit: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AdbcConnection,
            arg2: *mut AdbcError,
        ) -> AdbcStatusCode,
    >,
    pub ConnectionGetInfo: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AdbcConnection,
            arg2: *const u32,
            arg3: usize,
            arg4: *mut ArrowArrayStream,
            arg5: *mut AdbcError,
        ) -> AdbcStatusCode,
    >,
    pub ConnectionGetObjects: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AdbcConnection,
            arg2: ::std::os::raw::c_int,
            arg3: *const ::std::os::raw::c_char,
            arg4: *const ::std::os::raw::c_char,
            arg5: *const ::std::os::raw::c_char,
            arg6: *mut *const ::std::os::raw::c_char,
            arg7: *const ::std::os::raw::c_char,
            arg8: *mut ArrowArrayStream,
            arg9: *mut AdbcError,
        ) -> AdbcStatusCode,
    >,
    pub ConnectionGetTableSchema: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AdbcConnection,
            arg2: *const ::std::os::raw::c_char,
            arg3: *const ::std::os::raw::c_char,
            arg4: *const ::std::os::raw::c_char,
            arg5: *mut ArrowSchema,
            arg6: *mut AdbcError,
        ) -> AdbcStatusCode,
    >,
    pub ConnectionGetTableTypes: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AdbcConnection,
            arg2: *mut ArrowArrayStream,
            arg3: *mut AdbcError,
        ) -> AdbcStatusCode,
    >,
    pub ConnectionInit: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AdbcConnection,
            arg2: *mut AdbcDatabase,
            arg3: *mut AdbcError,
        ) -> AdbcStatusCode,
    >,
    pub ConnectionNew: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AdbcConnection,
            arg2: *mut AdbcError,
        ) -> AdbcStatusCode,
    >,
    pub ConnectionSetOption: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AdbcConnection,
            arg2: *const ::std::os::raw::c_char,
            arg3: *const ::std::os::raw::c_char,
            arg4: *mut AdbcError,
        ) -> AdbcStatusCode,
    >,
    pub ConnectionReadPartition: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AdbcConnection,
            arg2: *const u8,
            arg3: usize,
            arg4: *mut ArrowArrayStream,
            arg5: *mut AdbcError,
        ) -> AdbcStatusCode,
    >,
    pub ConnectionRelease: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AdbcConnection,
            arg2: *mut AdbcError,
        ) -> AdbcStatusCode,
    >,
    pub ConnectionRollback: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AdbcConnection,
            arg2: *mut AdbcError,
        ) -> AdbcStatusCode,
    >,
    pub StatementBind: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AdbcStatement,
            arg2: *mut ArrowArray,
            arg3: *mut ArrowSchema,
            arg4: *mut AdbcError,
        ) -> AdbcStatusCode,
    >,
    pub StatementBindStream: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AdbcStatement,
            arg2: *mut ArrowArrayStream,
            arg3: *mut AdbcError,
        ) -> AdbcStatusCode,
    >,
    pub StatementExecuteQuery: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AdbcStatement,
            arg2: *mut ArrowArrayStream,
            arg3: *mut i64,
            arg4: *mut AdbcError,
        ) -> AdbcStatusCode,
    >,
    pub StatementExecutePartitions: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AdbcStatement,
            arg2: *mut ArrowSchema,
            arg3: *mut AdbcPartitions,
            arg4: *mut i64,
            arg5: *mut AdbcError,
        ) -> AdbcStatusCode,
    >,
    pub StatementGetParameterSchema: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AdbcStatement,
            arg2: *mut ArrowSchema,
            arg3: *mut AdbcError,
        ) -> AdbcStatusCode,
    >,
    pub StatementNew: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AdbcConnection,
            arg2: *mut AdbcStatement,
            arg3: *mut AdbcError,
        ) -> AdbcStatusCode,
    >,
    pub StatementPrepare: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AdbcStatement,
            arg2: *mut AdbcError,
        ) -> AdbcStatusCode,
    >,
    pub StatementRelease: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AdbcStatement,
            arg2: *mut AdbcError,
        ) -> AdbcStatusCode,
    >,
    pub StatementSetOption: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AdbcStatement,
            arg2: *const ::std::os::raw::c_char,
            arg3: *const ::std::os::raw::c_char,
            arg4: *mut AdbcError,
        ) -> AdbcStatusCode,
    >,
    pub StatementSetSqlQuery: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AdbcStatement,
            arg2: *const ::std::os::raw::c_char,
            arg3: *mut AdbcError,
        ) -> AdbcStatusCode,
    >,
    pub StatementSetSubstraitPlan: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AdbcStatement,
            arg2: *const u8,
            arg3: usize,
            arg4: *mut AdbcError,
        ) -> AdbcStatusCode,
    >,
    /**adbc-1.1.0 ADBC API Revision 1.1.0

 Functions added in ADBC 1.1.0. For backwards compatibility,
 these members must not be accessed unless the version passed to
 the AdbcDriverInitFunc is greater than or equal to
 ADBC_VERSION_1_1_0.

 For a 1.0.0 driver being loaded by a 1.1.0 driver manager: the
 1.1.0 manager will allocate the new, expanded AdbcDriver struct
 and attempt to have the driver initialize it with
 ADBC_VERSION_1_1_0. This must return an error, after which the
 driver will try again with ADBC_VERSION_1_0_0. The driver must
 not access the new fields, which will carry undefined values.

 For a 1.1.0 driver being loaded by a 1.0.0 driver manager: the
 1.0.0 manager will allocate the old AdbcDriver struct and
 attempt to have the driver initialize it with
 ADBC_VERSION_1_0_0. The driver must not access the new fields,
 and should initialize the old fields.

 # */
    pub ErrorGetDetailCount: ::std::option::Option<
        unsafe extern "C" fn(error: *const AdbcError) -> ::std::os::raw::c_int,
    >,
    pub ErrorGetDetail: ::std::option::Option<
        unsafe extern "C" fn(
            error: *const AdbcError,
            index: ::std::os::raw::c_int,
        ) -> AdbcErrorDetail,
    >,
    pub ErrorFromArrayStream: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut ArrowArrayStream,
            status: *mut AdbcStatusCode,
        ) -> *const AdbcError,
    >,
    pub DatabaseGetOption: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AdbcDatabase,
            arg2: *const ::std::os::raw::c_char,
            arg3: *mut ::std::os::raw::c_char,
            arg4: *mut usize,
            arg5: *mut AdbcError,
        ) -> AdbcStatusCode,
    >,
    pub DatabaseGetOptionBytes: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AdbcDatabase,
            arg2: *const ::std::os::raw::c_char,
            arg3: *mut u8,
            arg4: *mut usize,
            arg5: *mut AdbcError,
        ) -> AdbcStatusCode,
    >,
    pub DatabaseGetOptionDouble: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AdbcDatabase,
            arg2: *const ::std::os::raw::c_char,
            arg3: *mut f64,
            arg4: *mut AdbcError,
        ) -> AdbcStatusCode,
    >,
    pub DatabaseGetOptionInt: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AdbcDatabase,
            arg2: *const ::std::os::raw::c_char,
            arg3: *mut i64,
            arg4: *mut AdbcError,
        ) -> AdbcStatusCode,
    >,
    pub DatabaseSetOptionBytes: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AdbcDatabase,
            arg2: *const ::std::os::raw::c_char,
            arg3: *const u8,
            arg4: usize,
            arg5: *mut AdbcError,
        ) -> AdbcStatusCode,
    >,
    pub DatabaseSetOptionDouble: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AdbcDatabase,
            arg2: *const ::std::os::raw::c_char,
            arg3: f64,
            arg4: *mut AdbcError,
        ) -> AdbcStatusCode,
    >,
    pub DatabaseSetOptionInt: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AdbcDatabase,
            arg2: *const ::std::os::raw::c_char,
            arg3: i64,
            arg4: *mut AdbcError,
        ) -> AdbcStatusCode,
    >,
    pub ConnectionCancel: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AdbcConnection,
            arg2: *mut AdbcError,
        ) -> AdbcStatusCode,
    >,
    pub ConnectionGetOption: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AdbcConnection,
            arg2: *const ::std::os::raw::c_char,
            arg3: *mut ::std::os::raw::c_char,
            arg4: *mut usize,
            arg5: *mut AdbcError,
        ) -> AdbcStatusCode,
    >,
    pub ConnectionGetOptionBytes: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AdbcConnection,
            arg2: *const ::std::os::raw::c_char,
            arg3: *mut u8,
            arg4: *mut usize,
            arg5: *mut AdbcError,
        ) -> AdbcStatusCode,
    >,
    pub ConnectionGetOptionDouble: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AdbcConnection,
            arg2: *const ::std::os::raw::c_char,
            arg3: *mut f64,
            arg4: *mut AdbcError,
        ) -> AdbcStatusCode,
    >,
    pub ConnectionGetOptionInt: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AdbcConnection,
            arg2: *const ::std::os::raw::c_char,
            arg3: *mut i64,
            arg4: *mut AdbcError,
        ) -> AdbcStatusCode,
    >,
    pub ConnectionGetStatistics: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AdbcConnection,
            arg2: *const ::std::os::raw::c_char,
            arg3: *const ::std::os::raw::c_char,
            arg4: *const ::std::os::raw::c_char,
            arg5: ::std::os::raw::c_char,
            arg6: *mut ArrowArrayStream,
            arg7: *mut AdbcError,
        ) -> AdbcStatusCode,
    >,
    pub ConnectionGetStatisticNames: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AdbcConnection,
            arg2: *mut ArrowArrayStream,
            arg3: *mut AdbcError,
        ) -> AdbcStatusCode,
    >,
    pub ConnectionSetOptionBytes: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AdbcConnection,
            arg2: *const ::std::os::raw::c_char,
            arg3: *const u8,
            arg4: usize,
            arg5: *mut AdbcError,
        ) -> AdbcStatusCode,
    >,
    pub ConnectionSetOptionDouble: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AdbcConnection,
            arg2: *const ::std::os::raw::c_char,
            arg3: f64,
            arg4: *mut AdbcError,
        ) -> AdbcStatusCode,
    >,
    pub ConnectionSetOptionInt: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AdbcConnection,
            arg2: *const ::std::os::raw::c_char,
            arg3: i64,
            arg4: *mut AdbcError,
        ) -> AdbcStatusCode,
    >,
    pub StatementCancel: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AdbcStatement,
            arg2: *mut AdbcError,
        ) -> AdbcStatusCode,
    >,
    pub StatementExecuteSchema: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AdbcStatement,
            arg2: *mut ArrowSchema,
            arg3: *mut AdbcError,
        ) -> AdbcStatusCode,
    >,
    pub StatementGetOption: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AdbcStatement,
            arg2: *const ::std::os::raw::c_char,
            arg3: *mut ::std::os::raw::c_char,
            arg4: *mut usize,
            arg5: *mut AdbcError,
        ) -> AdbcStatusCode,
    >,
    pub StatementGetOptionBytes: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AdbcStatement,
            arg2: *const ::std::os::raw::c_char,
            arg3: *mut u8,
            arg4: *mut usize,
            arg5: *mut AdbcError,
        ) -> AdbcStatusCode,
    >,
    pub StatementGetOptionDouble: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AdbcStatement,
            arg2: *const ::std::os::raw::c_char,
            arg3: *mut f64,
            arg4: *mut AdbcError,
        ) -> AdbcStatusCode,
    >,
    pub StatementGetOptionInt: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AdbcStatement,
            arg2: *const ::std::os::raw::c_char,
            arg3: *mut i64,
            arg4: *mut AdbcError,
        ) -> AdbcStatusCode,
    >,
    pub StatementSetOptionBytes: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AdbcStatement,
            arg2: *const ::std::os::raw::c_char,
            arg3: *const u8,
            arg4: usize,
            arg5: *mut AdbcError,
        ) -> AdbcStatusCode,
    >,
    pub StatementSetOptionDouble: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AdbcStatement,
            arg2: *const ::std::os::raw::c_char,
            arg3: f64,
            arg4: *mut AdbcError,
        ) -> AdbcStatusCode,
    >,
    pub StatementSetOptionInt: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AdbcStatement,
            arg2: *const ::std::os::raw::c_char,
            arg3: i64,
            arg4: *mut AdbcError,
        ) -> AdbcStatusCode,
    >,
}
#[test]
fn bindgen_test_layout_AdbcDriver() {
    const UNINIT: ::std::mem::MaybeUninit<AdbcDriver> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AdbcDriver>(),
        464usize,
        concat!("Size of: ", stringify!(AdbcDriver)),
    );
    assert_eq!(
        ::std::mem::align_of::<AdbcDriver>(),
        8usize,
        concat!("Alignment of ", stringify!(AdbcDriver)),
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).private_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(private_data),
        ),
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).private_manager) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(private_manager),
        ),
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).release) as usize - ptr as usize },
        16usize,
        concat!("Offset of field: ", stringify!(AdbcDriver), "::", stringify!(release)),
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DatabaseInit) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(DatabaseInit),
        ),
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DatabaseNew) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(DatabaseNew),
        ),
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).DatabaseSetOption) as usize - ptr as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(DatabaseSetOption),
        ),
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DatabaseRelease) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(DatabaseRelease),
        ),
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ConnectionCommit) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(ConnectionCommit),
        ),
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ConnectionGetInfo) as usize - ptr as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(ConnectionGetInfo),
        ),
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ConnectionGetObjects) as usize - ptr as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(ConnectionGetObjects),
        ),
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ConnectionGetTableSchema) as usize - ptr as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(ConnectionGetTableSchema),
        ),
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ConnectionGetTableTypes) as usize - ptr as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(ConnectionGetTableTypes),
        ),
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ConnectionInit) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(ConnectionInit),
        ),
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ConnectionNew) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(ConnectionNew),
        ),
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ConnectionSetOption) as usize - ptr as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(ConnectionSetOption),
        ),
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ConnectionReadPartition) as usize - ptr as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(ConnectionReadPartition),
        ),
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ConnectionRelease) as usize - ptr as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(ConnectionRelease),
        ),
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ConnectionRollback) as usize - ptr as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(ConnectionRollback),
        ),
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StatementBind) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(StatementBind),
        ),
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).StatementBindStream) as usize - ptr as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(StatementBindStream),
        ),
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).StatementExecuteQuery) as usize - ptr as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(StatementExecuteQuery),
        ),
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).StatementExecutePartitions) as usize
                - ptr as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(StatementExecutePartitions),
        ),
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).StatementGetParameterSchema) as usize
                - ptr as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(StatementGetParameterSchema),
        ),
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StatementNew) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(StatementNew),
        ),
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StatementPrepare) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(StatementPrepare),
        ),
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StatementRelease) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(StatementRelease),
        ),
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).StatementSetOption) as usize - ptr as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(StatementSetOption),
        ),
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).StatementSetSqlQuery) as usize - ptr as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(StatementSetSqlQuery),
        ),
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).StatementSetSubstraitPlan) as usize
                - ptr as usize
        },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(StatementSetSubstraitPlan),
        ),
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ErrorGetDetailCount) as usize - ptr as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(ErrorGetDetailCount),
        ),
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ErrorGetDetail) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(ErrorGetDetail),
        ),
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ErrorFromArrayStream) as usize - ptr as usize
        },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(ErrorFromArrayStream),
        ),
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).DatabaseGetOption) as usize - ptr as usize
        },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(DatabaseGetOption),
        ),
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).DatabaseGetOptionBytes) as usize - ptr as usize
        },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(DatabaseGetOptionBytes),
        ),
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).DatabaseGetOptionDouble) as usize - ptr as usize
        },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(DatabaseGetOptionDouble),
        ),
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).DatabaseGetOptionInt) as usize - ptr as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(DatabaseGetOptionInt),
        ),
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).DatabaseSetOptionBytes) as usize - ptr as usize
        },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(DatabaseSetOptionBytes),
        ),
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).DatabaseSetOptionDouble) as usize - ptr as usize
        },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(DatabaseSetOptionDouble),
        ),
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).DatabaseSetOptionInt) as usize - ptr as usize
        },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(DatabaseSetOptionInt),
        ),
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ConnectionCancel) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(ConnectionCancel),
        ),
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ConnectionGetOption) as usize - ptr as usize
        },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(ConnectionGetOption),
        ),
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ConnectionGetOptionBytes) as usize - ptr as usize
        },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(ConnectionGetOptionBytes),
        ),
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ConnectionGetOptionDouble) as usize
                - ptr as usize
        },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(ConnectionGetOptionDouble),
        ),
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ConnectionGetOptionInt) as usize - ptr as usize
        },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(ConnectionGetOptionInt),
        ),
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ConnectionGetStatistics) as usize - ptr as usize
        },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(ConnectionGetStatistics),
        ),
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ConnectionGetStatisticNames) as usize
                - ptr as usize
        },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(ConnectionGetStatisticNames),
        ),
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ConnectionSetOptionBytes) as usize - ptr as usize
        },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(ConnectionSetOptionBytes),
        ),
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ConnectionSetOptionDouble) as usize
                - ptr as usize
        },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(ConnectionSetOptionDouble),
        ),
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ConnectionSetOptionInt) as usize - ptr as usize
        },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(ConnectionSetOptionInt),
        ),
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StatementCancel) as usize - ptr as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(StatementCancel),
        ),
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).StatementExecuteSchema) as usize - ptr as usize
        },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(StatementExecuteSchema),
        ),
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).StatementGetOption) as usize - ptr as usize
        },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(StatementGetOption),
        ),
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).StatementGetOptionBytes) as usize - ptr as usize
        },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(StatementGetOptionBytes),
        ),
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).StatementGetOptionDouble) as usize - ptr as usize
        },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(StatementGetOptionDouble),
        ),
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).StatementGetOptionInt) as usize - ptr as usize
        },
        432usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(StatementGetOptionInt),
        ),
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).StatementSetOptionBytes) as usize - ptr as usize
        },
        440usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(StatementSetOptionBytes),
        ),
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).StatementSetOptionDouble) as usize - ptr as usize
        },
        448usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(StatementSetOptionDouble),
        ),
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).StatementSetOptionInt) as usize - ptr as usize
        },
        456usize,
        concat!(
            "Offset of field: ",
            stringify!(AdbcDriver),
            "::",
            stringify!(StatementSetOptionInt),
        ),
    );
}
extern "C" {
    /**Allocate a new (but uninitialized) database.

 Callers pass in a zero-initialized AdbcDatabase.

 Drivers should allocate their internal data structure and set the private_data
 field to point to the newly allocated struct. This struct should be released
 when AdbcDatabaseRelease is called.*/
    pub fn AdbcDatabaseNew(
        database: *mut AdbcDatabase,
        error: *mut AdbcError,
    ) -> AdbcStatusCode;
}
extern "C" {
    /**Get a string option of the database.

 This must always be thread-safe (other operations are not), though
 given the semantics here, it is not recommended to call GetOption
 concurrently with itself.

 length must be provided and must be the size of the buffer pointed
 to by value. If there is sufficient space, the driver will copy
 the option value (including the null terminator) to buffer and set
 length to the size of the actual value. If the buffer is too
 small, no data will be written and length will be set to the
 required length.

 In other words:

 - If output length <= input length, value will contain a value
 with length bytes.
 - If output length > input length, nothing has been written to
 value.

 For standard options, drivers must always support getting the
 option value (if they support getting option values at all) via
 the type specified in the option. (For example, an option set via
 SetOptionDouble must be retrievable via GetOptionDouble.) Drivers
 may also support getting a converted option value via other
 getters if needed. (For example, getting the string
 representation of a double option.)

 > Available since: ADBC API revision 1.1.0
 # Arguments

* `database` (direction in) - The database.
 * `key` (direction in) - The option to get.
 * `value` (direction out) - The option value.
 * `length` (direction in, out) - The length of value.
 * `error` (direction out) - An optional location to return an error
 message if necessary.
 # Returns

ADBC_STATUS_NOT_FOUND if the option is not recognized.*/
    pub fn AdbcDatabaseGetOption(
        database: *mut AdbcDatabase,
        key: *const ::std::os::raw::c_char,
        value: *mut ::std::os::raw::c_char,
        length: *mut usize,
        error: *mut AdbcError,
    ) -> AdbcStatusCode;
}
extern "C" {
    /**Get a bytestring option of the database.

 This must always be thread-safe (other operations are not), though
 given the semantics here, it is not recommended to call
 GetOptionBytes concurrently with itself.

 length must be provided and must be the size of the buffer pointed
 to by value. If there is sufficient space, the driver will copy
 the option value to buffer and set length to the size of the
 actual value. If the buffer is too small, no data will be written
 and length will be set to the required length.

 In other words:

 - If output length <= input length, value will contain a value
 with length bytes.
 - If output length > input length, nothing has been written to
 value.

 For standard options, drivers must always support getting the
 option value (if they support getting option values at all) via
 the type specified in the option. (For example, an option set via
 SetOptionDouble must be retrievable via GetOptionDouble.) Drivers
 may also support getting a converted option value via other
 getters if needed. (For example, getting the string
 representation of a double option.)

 > Available since: ADBC API revision 1.1.0
 # Arguments

* `database` (direction in) - The database.
 * `key` (direction in) - The option to get.
 * `value` (direction out) - The option value.
 * `length` (direction in, out) - The option value length.
 * `error` (direction out) - An optional location to return an error
 message if necessary.
 # Returns

ADBC_STATUS_NOT_FOUND if the option is not recognized.*/
    pub fn AdbcDatabaseGetOptionBytes(
        database: *mut AdbcDatabase,
        key: *const ::std::os::raw::c_char,
        value: *mut u8,
        length: *mut usize,
        error: *mut AdbcError,
    ) -> AdbcStatusCode;
}
extern "C" {
    /**Get a double option of the database.

 This must always be thread-safe (other operations are not).

 For standard options, drivers must always support getting the
 option value (if they support getting option values at all) via
 the type specified in the option. (For example, an option set via
 SetOptionDouble must be retrievable via GetOptionDouble.) Drivers
 may also support getting a converted option value via other
 getters if needed. (For example, getting the double
 representation of an integer option.)

 > Available since: ADBC API revision 1.1.0
 # Arguments

* `database` (direction in) - The database.
 * `key` (direction in) - The option to get.
 * `value` (direction out) - The option value.
 * `error` (direction out) - An optional location to return an error
 message if necessary.
 # Returns

ADBC_STATUS_NOT_FOUND if the option is not recognized.*/
    pub fn AdbcDatabaseGetOptionDouble(
        database: *mut AdbcDatabase,
        key: *const ::std::os::raw::c_char,
        value: *mut f64,
        error: *mut AdbcError,
    ) -> AdbcStatusCode;
}
extern "C" {
    /**Get an integer option of the database.

 This must always be thread-safe (other operations are not).

 For standard options, drivers must always support getting the
 option value (if they support getting option values at all) via
 the type specified in the option. (For example, an option set via
 SetOptionDouble must be retrievable via GetOptionDouble.) Drivers
 may also support getting a converted option value via other
 getters if needed. (For example, getting the integer
 representation of a double option.)

 > Available since: ADBC API revision 1.1.0
 # Arguments

* `database` (direction in) - The database.
 * `key` (direction in) - The option to get.
 * `value` (direction out) - The option value.
 * `error` (direction out) - An optional location to return an error
 message if necessary.
 # Returns

ADBC_STATUS_NOT_FOUND if the option is not recognized.*/
    pub fn AdbcDatabaseGetOptionInt(
        database: *mut AdbcDatabase,
        key: *const ::std::os::raw::c_char,
        value: *mut i64,
        error: *mut AdbcError,
    ) -> AdbcStatusCode;
}
extern "C" {
    /**Set a char* option.

 Options may be set before AdbcDatabaseInit. Some drivers may
 support setting options after initialization as well.

 # Arguments

* `database` (direction in) - The database.
 * `key` (direction in) - The option to set.
 * `value` (direction in) - The option value.
 * `error` (direction out) - An optional location to return an error
 message if necessary.
 # Returns

ADBC_STATUS_NOT_IMPLEMENTED if the option is not recognized*/
    pub fn AdbcDatabaseSetOption(
        database: *mut AdbcDatabase,
        key: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
        error: *mut AdbcError,
    ) -> AdbcStatusCode;
}
extern "C" {
    /**Set a bytestring option on a database.

 > Available since: ADBC API revision 1.1.0
 # Arguments

* `database` (direction in) - The database.
 * `key` (direction in) - The option to set.
 * `value` (direction in) - The option value.
 * `length` (direction in) - The option value length.
 * `error` (direction out) - An optional location to return an error
 message if necessary.
 # Returns

ADBC_STATUS_NOT_IMPLEMENTED if the option is not recognized*/
    pub fn AdbcDatabaseSetOptionBytes(
        database: *mut AdbcDatabase,
        key: *const ::std::os::raw::c_char,
        value: *const u8,
        length: usize,
        error: *mut AdbcError,
    ) -> AdbcStatusCode;
}
extern "C" {
    /**Set a double option on a database.

 > Available since: ADBC API revision 1.1.0
 # Arguments

* `database` (direction in) - The database.
 * `key` (direction in) - The option to set.
 * `value` (direction in) - The option value.
 * `error` (direction out) - An optional location to return an error
 message if necessary.
 # Returns

ADBC_STATUS_NOT_IMPLEMENTED if the option is not recognized*/
    pub fn AdbcDatabaseSetOptionDouble(
        database: *mut AdbcDatabase,
        key: *const ::std::os::raw::c_char,
        value: f64,
        error: *mut AdbcError,
    ) -> AdbcStatusCode;
}
extern "C" {
    /**Set an integer option on a database.

 > Available since: ADBC API revision 1.1.0
 # Arguments

* `database` (direction in) - The database.
 * `key` (direction in) - The option to set.
 * `value` (direction in) - The option value.
 * `error` (direction out) - An optional location to return an error
 message if necessary.
 # Returns

ADBC_STATUS_NOT_IMPLEMENTED if the option is not recognized*/
    pub fn AdbcDatabaseSetOptionInt(
        database: *mut AdbcDatabase,
        key: *const ::std::os::raw::c_char,
        value: i64,
        error: *mut AdbcError,
    ) -> AdbcStatusCode;
}
extern "C" {
    /**Finish setting options and initialize the database.

 Some drivers may support setting options after initialization
 as well.*/
    pub fn AdbcDatabaseInit(
        database: *mut AdbcDatabase,
        error: *mut AdbcError,
    ) -> AdbcStatusCode;
}
extern "C" {
    /**Destroy this database. No connections may exist.
 # Arguments

* `database` (direction in) - The database to release.
 * `error` (direction out) - An optional location to return an error
 message if necessary.*/
    pub fn AdbcDatabaseRelease(
        database: *mut AdbcDatabase,
        error: *mut AdbcError,
    ) -> AdbcStatusCode;
}
extern "C" {
    /**Allocate a new (but uninitialized) connection.

 Callers pass in a zero-initialized AdbcConnection.

 Drivers should allocate their internal data structure and set the private_data
 field to point to the newly allocated struct. This struct should be released
 when AdbcConnectionRelease is called.*/
    pub fn AdbcConnectionNew(
        connection: *mut AdbcConnection,
        error: *mut AdbcError,
    ) -> AdbcStatusCode;
}
extern "C" {
    /**Set a char* option.

 Options may be set before AdbcConnectionInit. Some drivers may
 support setting options after initialization as well.

 # Arguments

* `connection` (direction in) - The database connection.
 * `key` (direction in) - The option to set.
 * `value` (direction in) - The option value.
 * `error` (direction out) - An optional location to return an error
 message if necessary.
 # Returns

ADBC_STATUS_NOT_IMPLEMENTED if the option is not recognized*/
    pub fn AdbcConnectionSetOption(
        connection: *mut AdbcConnection,
        key: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
        error: *mut AdbcError,
    ) -> AdbcStatusCode;
}
extern "C" {
    /**Set a bytestring option on a connection.

 > Available since: ADBC API revision 1.1.0
 # Arguments

* `connection` (direction in) - The connection.
 * `key` (direction in) - The option to set.
 * `value` (direction in) - The option value.
 * `length` (direction in) - The option value length.
 * `error` (direction out) - An optional location to return an error
 message if necessary.
 # Returns

ADBC_STATUS_NOT_IMPLEMENTED if the option is not recognized*/
    pub fn AdbcConnectionSetOptionBytes(
        connection: *mut AdbcConnection,
        key: *const ::std::os::raw::c_char,
        value: *const u8,
        length: usize,
        error: *mut AdbcError,
    ) -> AdbcStatusCode;
}
extern "C" {
    /**Set an integer option.

 Options may be set before AdbcConnectionInit. Some drivers may
 support setting options after initialization as well.

 > Available since: ADBC API revision 1.1.0
 # Arguments

* `connection` (direction in) - The database connection.
 * `key` (direction in) - The option to set.
 * `value` (direction in) - The option value.
 * `error` (direction out) - An optional location to return an error
 message if necessary.
 # Returns

ADBC_STATUS_NOT_IMPLEMENTED if the option is not recognized*/
    pub fn AdbcConnectionSetOptionInt(
        connection: *mut AdbcConnection,
        key: *const ::std::os::raw::c_char,
        value: i64,
        error: *mut AdbcError,
    ) -> AdbcStatusCode;
}
extern "C" {
    /**Set a double option.

 Options may be set before AdbcConnectionInit. Some drivers may
 support setting options after initialization as well.

 > Available since: ADBC API revision 1.1.0
 # Arguments

* `connection` (direction in) - The database connection.
 * `key` (direction in) - The option to set.
 * `value` (direction in) - The option value.
 * `error` (direction out) - An optional location to return an error
 message if necessary.
 # Returns

ADBC_STATUS_NOT_IMPLEMENTED if the option is not recognized*/
    pub fn AdbcConnectionSetOptionDouble(
        connection: *mut AdbcConnection,
        key: *const ::std::os::raw::c_char,
        value: f64,
        error: *mut AdbcError,
    ) -> AdbcStatusCode;
}
extern "C" {
    /**Finish setting options and initialize the connection.

 Some drivers may support setting options after initialization
 as well.*/
    pub fn AdbcConnectionInit(
        connection: *mut AdbcConnection,
        database: *mut AdbcDatabase,
        error: *mut AdbcError,
    ) -> AdbcStatusCode;
}
extern "C" {
    /**Destroy this connection.

 # Arguments

* `connection` (direction in) - The connection to release.
 * `error` (direction out) - An optional location to return an error
 message if necessary.*/
    pub fn AdbcConnectionRelease(
        connection: *mut AdbcConnection,
        error: *mut AdbcError,
    ) -> AdbcStatusCode;
}
extern "C" {
    /**Cancel the in-progress operation on a connection.

 This can be called during AdbcConnectionGetObjects (or similar),
 or while consuming an ArrowArrayStream returned from such.
 Calling this function should make the other functions return
 ADBC_STATUS_CANCELLED (from ADBC functions) or ECANCELED (from
 methods of ArrowArrayStream). (It is not guaranteed to, for
 instance, the result set may be buffered in memory already.)

 This must always be thread-safe (other operations are not). It is
 not necessarily signal-safe.

 > Available since: ADBC API revision 1.1.0

 # Arguments

* `connection` (direction in) - The connection to cancel.
 * `error` (direction out) - An optional location to return an error
 message if necessary.

 # Returns

ADBC_STATUS_INVALID_STATE if there is no operation to cancel.
 ADBC_STATUS_UNKNOWN if the operation could not be cancelled.*/
    pub fn AdbcConnectionCancel(
        connection: *mut AdbcConnection,
        error: *mut AdbcError,
    ) -> AdbcStatusCode;
}
extern "C" {
    /**Get metadata about the database/driver.

 The result is an Arrow dataset with the following schema:

 Field Name | Field Type
 ----------------------------|------------------------
 info_name | uint32 not null
 info_value | INFO_SCHEMA

 INFO_SCHEMA is a dense union with members:

 Field Name (Type Code) | Field Type
 ----------------------------|------------------------
 string_value (0) | utf8
 bool_value (1) | bool
 int64_value (2) | int64
 int32_bitmask (3) | int32
 string_list (4) | list<utf8>
 int32_to_int32_list_map (5) | map<int32, list<int32>>

 Each metadatum is identified by an integer code. The recognized
 codes are defined as constants. Codes [0, 10_000) are reserved
 for ADBC usage. Drivers/vendors will ignore requests for
 unrecognized codes (the row will be omitted from the result).

 Since ADBC 1.1.0: the range [500, 1_000) is reserved for "XDBC"
 information, which is the same metadata provided by the same info
 code range in the Arrow Flight SQL GetSqlInfo RPC.

 # Arguments

* `connection` (direction in) - The connection to query.
 * `info_codes` (direction in) - A list of metadata codes to fetch, or NULL
 to fetch all.
 * `info_codes_length` (direction in) - The length of the info_codes
 parameter. Ignored if info_codes is NULL.
 * `out` (direction out) - The result set.
 * `error` (direction out) - Error details, if an error occurs.*/
    pub fn AdbcConnectionGetInfo(
        connection: *mut AdbcConnection,
        info_codes: *const u32,
        info_codes_length: usize,
        out: *mut ArrowArrayStream,
        error: *mut AdbcError,
    ) -> AdbcStatusCode;
}
extern "C" {
    /**Get a hierarchical view of all catalogs, database schemas,
 tables, and columns.

 The result is an Arrow dataset with the following schema:

 | Field Name | Field Type |
 |--------------------------|-------------------------|
 | catalog_name | utf8 |
 | catalog_db_schemas | list<DB_SCHEMA_SCHEMA> |

 DB_SCHEMA_SCHEMA is a Struct with fields:

 | Field Name | Field Type |
 |--------------------------|-------------------------|
 | db_schema_name | utf8 |
 | db_schema_tables | list<TABLE_SCHEMA> |

 TABLE_SCHEMA is a Struct with fields:

 | Field Name | Field Type |
 |--------------------------|-------------------------|
 | table_name | utf8 not null |
 | table_type | utf8 not null |
 | table_columns | list<COLUMN_SCHEMA> |
 | table_constraints | list<CONSTRAINT_SCHEMA> |

 COLUMN_SCHEMA is a Struct with fields:

 | Field Name | Field Type | Comments |
 |--------------------------|-------------------------|----------|
 | column_name | utf8 not null | |
 | ordinal_position | int32 | (1) |
 | remarks | utf8 | (2) |
 | xdbc_data_type | int16 | (3) |
 | xdbc_type_name | utf8 | (3) |
 | xdbc_column_size | int32 | (3) |
 | xdbc_decimal_digits | int16 | (3) |
 | xdbc_num_prec_radix | int16 | (3) |
 | xdbc_nullable | int16 | (3) |
 | xdbc_column_def | utf8 | (3) |
 | xdbc_sql_data_type | int16 | (3) |
 | xdbc_datetime_sub | int16 | (3) |
 | xdbc_char_octet_length | int32 | (3) |
 | xdbc_is_nullable | utf8 | (3) |
 | xdbc_scope_catalog | utf8 | (3) |
 | xdbc_scope_schema | utf8 | (3) |
 | xdbc_scope_table | utf8 | (3) |
 | xdbc_is_autoincrement | bool | (3) |
 | xdbc_is_generatedcolumn | bool | (3) |

 1. The column's ordinal position in the table (starting from 1).
 2. Database-specific description of the column.
 3. Optional value. Should be null if not supported by the driver.
 xdbc_ values are meant to provide JDBC/ODBC-compatible metadata
 in an agnostic manner.

 CONSTRAINT_SCHEMA is a Struct with fields:

 | Field Name | Field Type | Comments |
 |--------------------------|-------------------------|----------|
 | constraint_name | utf8 | |
 | constraint_type | utf8 not null | (1) |
 | constraint_column_names | list<utf8> not null | (2) |
 | constraint_column_usage | list<USAGE_SCHEMA> | (3) |

 1. One of 'CHECK', 'FOREIGN KEY', 'PRIMARY KEY', or 'UNIQUE'.
 2. The columns on the current table that are constrained, in
 order.
 3. For FOREIGN KEY only, the referenced table and columns.

 USAGE_SCHEMA is a Struct with fields:

 | Field Name | Field Type |
 |--------------------------|-------------------------|
 | fk_catalog | utf8 |
 | fk_db_schema | utf8 |
 | fk_table | utf8 not null |
 | fk_column_name | utf8 not null |

 This AdbcConnection must outlive the returned ArrowArrayStream.

 # Arguments

* `connection` (direction in) - The database connection.
 * `depth` (direction in) - The level of nesting to display. If 0, display
 all levels. If 1, display only catalogs (i.e. catalog_schemas
 will be null). If 2, display only catalogs and schemas
 (i.e. db_schema_tables will be null), and so on.
 * `catalog` (direction in) - Only show tables in the given catalog. If NULL,
 do not filter by catalog. If an empty string, only show tables
 without a catalog. May be a search pattern (see section
 documentation).
 * `db_schema` (direction in) - Only show tables in the given database schema. If
 NULL, do not filter by database schema. If an empty string, only show
 tables without a database schema. May be a search pattern (see section
 documentation).
 * `table_name` (direction in) - Only show tables with the given name. If NULL, do not
 filter by name. May be a search pattern (see section documentation).
 * `table_type` (direction in) - Only show tables matching one of the given table
 types. If NULL, show tables of any type. Valid table types can be fetched
 from GetTableTypes. Terminate the list with a NULL entry.
 * `column_name` (direction in) - Only show columns with the given name. If
 NULL, do not filter by name. May be a search pattern (see
 section documentation).
 * `out` (direction out) - The result set.
 * `error` (direction out) - Error details, if an error occurs.*/
    pub fn AdbcConnectionGetObjects(
        connection: *mut AdbcConnection,
        depth: ::std::os::raw::c_int,
        catalog: *const ::std::os::raw::c_char,
        db_schema: *const ::std::os::raw::c_char,
        table_name: *const ::std::os::raw::c_char,
        table_type: *mut *const ::std::os::raw::c_char,
        column_name: *const ::std::os::raw::c_char,
        out: *mut ArrowArrayStream,
        error: *mut AdbcError,
    ) -> AdbcStatusCode;
}
extern "C" {
    /**Get a string option of the connection.

 This must always be thread-safe (other operations are not), though
 given the semantics here, it is not recommended to call GetOption
 concurrently with itself.

 length must be provided and must be the size of the buffer pointed
 to by value. If there is sufficient space, the driver will copy
 the option value (including the null terminator) to buffer and set
 length to the size of the actual value. If the buffer is too
 small, no data will be written and length will be set to the
 required length.

 In other words:

 - If output length <= input length, value will contain a value
 with length bytes.
 - If output length > input length, nothing has been written to
 value.

 > Available since: ADBC API revision 1.1.0
 # Arguments

* `connection` (direction in) - The database connection.
 * `key` (direction in) - The option to get.
 * `value` (direction out) - The option value.
 * `length` (direction in, out) - The length of value.
 * `error` (direction out) - An optional location to return an error
 message if necessary.
 # Returns

ADBC_STATUS_NOT_FOUND if the option is not recognized.*/
    pub fn AdbcConnectionGetOption(
        connection: *mut AdbcConnection,
        key: *const ::std::os::raw::c_char,
        value: *mut ::std::os::raw::c_char,
        length: *mut usize,
        error: *mut AdbcError,
    ) -> AdbcStatusCode;
}
extern "C" {
    /**Get a bytestring option of the connection.

 This must always be thread-safe (other operations are not), though
 given the semantics here, it is not recommended to call
 GetOptionBytes concurrently with itself.

 length must be provided and must be the size of the buffer pointed
 to by value. If there is sufficient space, the driver will copy
 the option value to buffer and set length to the size of the
 actual value. If the buffer is too small, no data will be written
 and length will be set to the required length.

 In other words:

 - If output length <= input length, value will contain a value
 with length bytes.
 - If output length > input length, nothing has been written to
 value.

 For standard options, drivers must always support getting the
 option value (if they support getting option values at all) via
 the type specified in the option. (For example, an option set via
 SetOptionDouble must be retrievable via GetOptionDouble.) Drivers
 may also support getting a converted option value via other
 getters if needed. (For example, getting the string
 representation of a double option.)

 > Available since: ADBC API revision 1.1.0
 # Arguments

* `connection` (direction in) - The connection.
 * `key` (direction in) - The option to get.
 * `value` (direction out) - The option value.
 * `length` (direction in, out) - The option value length.
 * `error` (direction out) - An optional location to return an error
 message if necessary.
 # Returns

ADBC_STATUS_NOT_FOUND if the option is not recognized.*/
    pub fn AdbcConnectionGetOptionBytes(
        connection: *mut AdbcConnection,
        key: *const ::std::os::raw::c_char,
        value: *mut u8,
        length: *mut usize,
        error: *mut AdbcError,
    ) -> AdbcStatusCode;
}
extern "C" {
    /**Get an integer option of the connection.

 This must always be thread-safe (other operations are not).

 For standard options, drivers must always support getting the
 option value (if they support getting option values at all) via
 the type specified in the option. (For example, an option set via
 SetOptionDouble must be retrievable via GetOptionDouble.) Drivers
 may also support getting a converted option value via other
 getters if needed. (For example, getting the string
 representation of a double option.)

 > Available since: ADBC API revision 1.1.0
 # Arguments

* `connection` (direction in) - The database connection.
 * `key` (direction in) - The option to get.
 * `value` (direction out) - The option value.
 * `error` (direction out) - An optional location to return an error
 message if necessary.
 # Returns

ADBC_STATUS_NOT_FOUND if the option is not recognized.*/
    pub fn AdbcConnectionGetOptionInt(
        connection: *mut AdbcConnection,
        key: *const ::std::os::raw::c_char,
        value: *mut i64,
        error: *mut AdbcError,
    ) -> AdbcStatusCode;
}
extern "C" {
    /**Get a double option of the connection.

 This must always be thread-safe (other operations are not).

 For standard options, drivers must always support getting the
 option value (if they support getting option values at all) via
 the type specified in the option. (For example, an option set via
 SetOptionDouble must be retrievable via GetOptionDouble.) Drivers
 may also support getting a converted option value via other
 getters if needed. (For example, getting the string
 representation of a double option.)

 > Available since: ADBC API revision 1.1.0
 # Arguments

* `connection` (direction in) - The database connection.
 * `key` (direction in) - The option to get.
 * `value` (direction out) - The option value.
 * `error` (direction out) - An optional location to return an error
 message if necessary.
 # Returns

ADBC_STATUS_NOT_FOUND if the option is not recognized.*/
    pub fn AdbcConnectionGetOptionDouble(
        connection: *mut AdbcConnection,
        key: *const ::std::os::raw::c_char,
        value: *mut f64,
        error: *mut AdbcError,
    ) -> AdbcStatusCode;
}
extern "C" {
    /**Get statistics about the data distribution of table(s).

 The result is an Arrow dataset with the following schema:

 | Field Name | Field Type |
 |--------------------------|----------------------------------|
 | catalog_name | utf8 |
 | catalog_db_schemas | list<DB_SCHEMA_SCHEMA> not null |

 DB_SCHEMA_SCHEMA is a Struct with fields:

 | Field Name | Field Type |
 |--------------------------|----------------------------------|
 | db_schema_name | utf8 |
 | db_schema_statistics | list<STATISTICS_SCHEMA> not null |

 STATISTICS_SCHEMA is a Struct with fields:

 | Field Name | Field Type | Comments |
 |--------------------------|----------------------------------| -------- |
 | table_name | utf8 not null | |
 | column_name | utf8 | (1) |
 | statistic_key | int16 not null | (2) |
 | statistic_value | VALUE_SCHEMA not null | |
 | statistic_is_approximate | bool not null | (3) |

 1. If null, then the statistic applies to the entire table.
 2. A dictionary-encoded statistic name (although we do not use the Arrow
 dictionary type). Values in [0, 1024) are reserved for ADBC. Other
 values are for implementation-specific statistics. For the definitions
 of predefined statistic types, see adbc-table-statistics. To get
 driver-specific statistic names, use AdbcConnectionGetStatisticNames.
 3. If true, then the value is approximate or best-effort.

 VALUE_SCHEMA is a dense union with members:

 | Field Name | Field Type |
 |--------------------------|----------------------------------|
 | int64 | int64 |
 | uint64 | uint64 |
 | float64 | float64 |
 | binary | binary |

 This AdbcConnection must outlive the returned ArrowArrayStream.

 > Available since: ADBC API revision 1.1.0
 # Arguments

* `connection` (direction in) - The database connection.
 * `catalog` (direction in) - The catalog (or nullptr). May be a search
 pattern (see section documentation).
 * `db_schema` (direction in) - The database schema (or nullptr). May be a
 search pattern (see section documentation).
 * `table_name` (direction in) - The table name (or nullptr). May be a
 search pattern (see section documentation).
 * `approximate` (direction in) - If zero, request exact values of
 statistics, else allow for best-effort, approximate, or cached
 values. The database may return approximate values regardless,
 as indicated in the result. Requesting exact values may be
 expensive or unsupported.
 * `out` (direction out) - The result set.
 * `error` (direction out) - Error details, if an error occurs.*/
    pub fn AdbcConnectionGetStatistics(
        connection: *mut AdbcConnection,
        catalog: *const ::std::os::raw::c_char,
        db_schema: *const ::std::os::raw::c_char,
        table_name: *const ::std::os::raw::c_char,
        approximate: ::std::os::raw::c_char,
        out: *mut ArrowArrayStream,
        error: *mut AdbcError,
    ) -> AdbcStatusCode;
}
extern "C" {
    /**Get the names of statistics specific to this driver.

 The result is an Arrow dataset with the following schema:

 Field Name | Field Type
 ---------------|----------------
 statistic_name | utf8 not null
 statistic_key | int16 not null

 > Available since: ADBC API revision 1.1.0
 # Arguments

* `connection` (direction in) - The database connection.
 * `out` (direction out) - The result set.
 * `error` (direction out) - Error details, if an error occurs.*/
    pub fn AdbcConnectionGetStatisticNames(
        connection: *mut AdbcConnection,
        out: *mut ArrowArrayStream,
        error: *mut AdbcError,
    ) -> AdbcStatusCode;
}
extern "C" {
    /**Get the Arrow schema of a table.

 # Arguments

* `connection` (direction in) - The database connection.
 * `catalog` (direction in) - The catalog (or nullptr if not applicable).
 * `db_schema` (direction in) - The database schema (or nullptr if not applicable).
 * `table_name` (direction in) - The table name.
 * `schema` (direction out) - The table schema.
 * `error` (direction out) - Error details, if an error occurs.*/
    pub fn AdbcConnectionGetTableSchema(
        connection: *mut AdbcConnection,
        catalog: *const ::std::os::raw::c_char,
        db_schema: *const ::std::os::raw::c_char,
        table_name: *const ::std::os::raw::c_char,
        schema: *mut ArrowSchema,
        error: *mut AdbcError,
    ) -> AdbcStatusCode;
}
extern "C" {
    /**Get a list of table types in the database.

 The result is an Arrow dataset with the following schema:

 Field Name | Field Type
 ---------------|--------------
 table_type | utf8 not null

 This AdbcConnection must outlive the returned ArrowArrayStream.

 # Arguments

* `connection` (direction in) - The database connection.
 * `out` (direction out) - The result set.
 * `error` (direction out) - Error details, if an error occurs.*/
    pub fn AdbcConnectionGetTableTypes(
        connection: *mut AdbcConnection,
        out: *mut ArrowArrayStream,
        error: *mut AdbcError,
    ) -> AdbcStatusCode;
}
extern "C" {
    /**Construct a statement for a partition of a query. The
 results can then be read independently.

 A partition can be retrieved from AdbcPartitions.

 This AdbcConnection must outlive the returned ArrowArrayStream.

 # Arguments

* `connection` (direction in) - The connection to use. This does not have
 to be the same connection that the partition was created on.
 * `serialized_partition` (direction in) - The partition descriptor.
 * `serialized_length` (direction in) - The partition descriptor length.
 * `out` (direction out) - The result set.
 * `error` (direction out) - Error details, if an error occurs.*/
    pub fn AdbcConnectionReadPartition(
        connection: *mut AdbcConnection,
        serialized_partition: *const u8,
        serialized_length: usize,
        out: *mut ArrowArrayStream,
        error: *mut AdbcError,
    ) -> AdbcStatusCode;
}
extern "C" {
    /**Commit any pending transactions. Only used if autocommit is
 disabled.

 Behavior is undefined if this is mixed with SQL transaction
 statements.*/
    pub fn AdbcConnectionCommit(
        connection: *mut AdbcConnection,
        error: *mut AdbcError,
    ) -> AdbcStatusCode;
}
extern "C" {
    /**Roll back any pending transactions. Only used if autocommit
 is disabled.

 Behavior is undefined if this is mixed with SQL transaction
 statements.*/
    pub fn AdbcConnectionRollback(
        connection: *mut AdbcConnection,
        error: *mut AdbcError,
    ) -> AdbcStatusCode;
}
extern "C" {
    /**Create a new statement for a given connection.

 Callers pass in a zero-initialized AdbcStatement.

 Drivers should allocate their internal data structure and set the private_data
 field to point to the newly allocated struct. This struct should be released
 when AdbcStatementRelease is called.*/
    pub fn AdbcStatementNew(
        connection: *mut AdbcConnection,
        statement: *mut AdbcStatement,
        error: *mut AdbcError,
    ) -> AdbcStatusCode;
}
extern "C" {
    /**Destroy a statement.
 # Arguments

* `statement` (direction in) - The statement to release.
 * `error` (direction out) - An optional location to return an error
 message if necessary.*/
    pub fn AdbcStatementRelease(
        statement: *mut AdbcStatement,
        error: *mut AdbcError,
    ) -> AdbcStatusCode;
}
extern "C" {
    /**Execute a statement and get the results.

 This invalidates any prior result sets. This AdbcStatement must
 outlive the returned ArrowArrayStream.

 Since ADBC 1.1.0: releasing the returned ArrowArrayStream without
 consuming it fully is equivalent to calling AdbcStatementCancel.

 # Arguments

* `statement` (direction in) - The statement to execute.
 * `out` (direction out) - The results. Pass NULL if the client does not
 expect a result set.
 * `rows_affected` (direction out) - The number of rows affected if known,
 else -1. Pass NULL if the client does not want this information.
 * `error` (direction out) - An optional location to return an error
 message if necessary.*/
    pub fn AdbcStatementExecuteQuery(
        statement: *mut AdbcStatement,
        out: *mut ArrowArrayStream,
        rows_affected: *mut i64,
        error: *mut AdbcError,
    ) -> AdbcStatusCode;
}
extern "C" {
    /**Get the schema of the result set of a query without
 executing it.

 This invalidates any prior result sets.

 Depending on the driver, this may require first executing
 AdbcStatementPrepare.

 > Available since: ADBC API revision 1.1.0

 # Arguments

* `statement` (direction in) - The statement to execute.
 * `out` (direction out) - The result schema.
 * `error` (direction out) - An optional location to return an error
 message if necessary.

 # Returns

ADBC_STATUS_NOT_IMPLEMENTED if the driver does not support this.*/
    pub fn AdbcStatementExecuteSchema(
        statement: *mut AdbcStatement,
        schema: *mut ArrowSchema,
        error: *mut AdbcError,
    ) -> AdbcStatusCode;
}
extern "C" {
    /**Turn this statement into a prepared statement to be
 executed multiple times.

 This invalidates any prior result sets.*/
    pub fn AdbcStatementPrepare(
        statement: *mut AdbcStatement,
        error: *mut AdbcError,
    ) -> AdbcStatusCode;
}
extern "C" {
    /**Set the SQL query to execute.

 The query can then be executed with AdbcStatementExecute. For
 queries expected to be executed repeatedly, AdbcStatementPrepare
 the statement first.

 # Arguments

* `statement` (direction in) - The statement.
 * `query` (direction in) - The query to execute.
 * `error` (direction out) - Error details, if an error occurs.*/
    pub fn AdbcStatementSetSqlQuery(
        statement: *mut AdbcStatement,
        query: *const ::std::os::raw::c_char,
        error: *mut AdbcError,
    ) -> AdbcStatusCode;
}
extern "C" {
    /**Set the Substrait plan to execute.

 The query can then be executed with AdbcStatementExecute. For
 queries expected to be executed repeatedly, AdbcStatementPrepare
 the statement first.

 # Arguments

* `statement` (direction in) - The statement.
 * `plan` (direction in) - The serialized substrait.Plan to execute.
 * `length` (direction in) - The length of the serialized plan.
 * `error` (direction out) - Error details, if an error occurs.*/
    pub fn AdbcStatementSetSubstraitPlan(
        statement: *mut AdbcStatement,
        plan: *const u8,
        length: usize,
        error: *mut AdbcError,
    ) -> AdbcStatusCode;
}
extern "C" {
    /**Bind Arrow data. This can be used for bulk inserts or
 prepared statements.

 # Arguments

* `statement` (direction in) - The statement to bind to.
 * `values` (direction in) - The values to bind. The driver will call the
 release callback itself, although it may not do this until the
 statement is released.
 * `schema` (direction in) - The schema of the values to bind.
 * `error` (direction out) - An optional location to return an error message
 if necessary.*/
    pub fn AdbcStatementBind(
        statement: *mut AdbcStatement,
        values: *mut ArrowArray,
        schema: *mut ArrowSchema,
        error: *mut AdbcError,
    ) -> AdbcStatusCode;
}
extern "C" {
    /**Bind Arrow data. This can be used for bulk inserts or
 prepared statements.
 # Arguments

* `statement` (direction in) - The statement to bind to.
 * `stream` (direction in) - The values to bind. The driver will call the
 release callback itself, although it may not do this until the
 statement is released.
 * `error` (direction out) - An optional location to return an error message
 if necessary.*/
    pub fn AdbcStatementBindStream(
        statement: *mut AdbcStatement,
        stream: *mut ArrowArrayStream,
        error: *mut AdbcError,
    ) -> AdbcStatusCode;
}
extern "C" {
    /**Cancel execution of an in-progress query.

 This can be called during AdbcStatementExecuteQuery (or similar),
 or while consuming an ArrowArrayStream returned from such.
 Calling this function should make the other functions return
 ADBC_STATUS_CANCELLED (from ADBC functions) or ECANCELED (from
 methods of ArrowArrayStream). (It is not guaranteed to, for
 instance, the result set may be buffered in memory already.)

 This must always be thread-safe (other operations are not). It is
 not necessarily signal-safe.

 > Available since: ADBC API revision 1.1.0

 # Arguments

* `statement` (direction in) - The statement to cancel.
 * `error` (direction out) - An optional location to return an error
 message if necessary.

 # Returns

ADBC_STATUS_INVALID_STATE if there is no query to cancel.
 ADBC_STATUS_UNKNOWN if the query could not be cancelled.*/
    pub fn AdbcStatementCancel(
        statement: *mut AdbcStatement,
        error: *mut AdbcError,
    ) -> AdbcStatusCode;
}
extern "C" {
    /**Get a string option of the statement.

 This must always be thread-safe (other operations are not), though
 given the semantics here, it is not recommended to call GetOption
 concurrently with itself.

 length must be provided and must be the size of the buffer pointed
 to by value. If there is sufficient space, the driver will copy
 the option value (including the null terminator) to buffer and set
 length to the size of the actual value. If the buffer is too
 small, no data will be written and length will be set to the
 required length.

 In other words:

 - If output length <= input length, value will contain a value
 with length bytes.
 - If output length > input length, nothing has been written to
 value.

 For standard options, drivers must always support getting the
 option value (if they support getting option values at all) via
 the type specified in the option. (For example, an option set via
 SetOptionDouble must be retrievable via GetOptionDouble.) Drivers
 may also support getting a converted option value via other
 getters if needed. (For example, getting the string
 representation of a double option.)

 > Available since: ADBC API revision 1.1.0
 # Arguments

* `statement` (direction in) - The statement.
 * `key` (direction in) - The option to get.
 * `value` (direction out) - The option value.
 * `length` (direction in, out) - The length of value.
 * `error` (direction out) - An optional location to return an error
 message if necessary.
 # Returns

ADBC_STATUS_NOT_FOUND if the option is not recognized.*/
    pub fn AdbcStatementGetOption(
        statement: *mut AdbcStatement,
        key: *const ::std::os::raw::c_char,
        value: *mut ::std::os::raw::c_char,
        length: *mut usize,
        error: *mut AdbcError,
    ) -> AdbcStatusCode;
}
extern "C" {
    /**Get a bytestring option of the statement.

 This must always be thread-safe (other operations are not), though
 given the semantics here, it is not recommended to call
 GetOptionBytes concurrently with itself.

 length must be provided and must be the size of the buffer pointed
 to by value. If there is sufficient space, the driver will copy
 the option value to buffer and set length to the size of the
 actual value. If the buffer is too small, no data will be written
 and length will be set to the required length.

 In other words:

 - If output length <= input length, value will contain a value
 with length bytes.
 - If output length > input length, nothing has been written to
 value.

 For standard options, drivers must always support getting the
 option value (if they support getting option values at all) via
 the type specified in the option. (For example, an option set via
 SetOptionDouble must be retrievable via GetOptionDouble.) Drivers
 may also support getting a converted option value via other
 getters if needed. (For example, getting the string
 representation of a double option.)

 > Available since: ADBC API revision 1.1.0
 # Arguments

* `statement` (direction in) - The statement.
 * `key` (direction in) - The option to get.
 * `value` (direction out) - The option value.
 * `length` (direction in, out) - The option value length.
 * `error` (direction out) - An optional location to return an error
 message if necessary.
 # Returns

ADBC_STATUS_NOT_FOUND if the option is not recognized.*/
    pub fn AdbcStatementGetOptionBytes(
        statement: *mut AdbcStatement,
        key: *const ::std::os::raw::c_char,
        value: *mut u8,
        length: *mut usize,
        error: *mut AdbcError,
    ) -> AdbcStatusCode;
}
extern "C" {
    /**Get an integer option of the statement.

 This must always be thread-safe (other operations are not).

 For standard options, drivers must always support getting the
 option value (if they support getting option values at all) via
 the type specified in the option. (For example, an option set via
 SetOptionDouble must be retrievable via GetOptionDouble.) Drivers
 may also support getting a converted option value via other
 getters if needed. (For example, getting the string
 representation of a double option.)

 > Available since: ADBC API revision 1.1.0
 # Arguments

* `statement` (direction in) - The statement.
 * `key` (direction in) - The option to get.
 * `value` (direction out) - The option value.
 * `error` (direction out) - An optional location to return an error
 message if necessary.
 # Returns

ADBC_STATUS_NOT_FOUND if the option is not recognized.*/
    pub fn AdbcStatementGetOptionInt(
        statement: *mut AdbcStatement,
        key: *const ::std::os::raw::c_char,
        value: *mut i64,
        error: *mut AdbcError,
    ) -> AdbcStatusCode;
}
extern "C" {
    /**Get a double option of the statement.

 This must always be thread-safe (other operations are not).

 For standard options, drivers must always support getting the
 option value (if they support getting option values at all) via
 the type specified in the option. (For example, an option set via
 SetOptionDouble must be retrievable via GetOptionDouble.) Drivers
 may also support getting a converted option value via other
 getters if needed. (For example, getting the string
 representation of a double option.)

 > Available since: ADBC API revision 1.1.0
 # Arguments

* `statement` (direction in) - The statement.
 * `key` (direction in) - The option to get.
 * `value` (direction out) - The option value.
 * `error` (direction out) - An optional location to return an error
 message if necessary.
 # Returns

ADBC_STATUS_NOT_FOUND if the option is not recognized.*/
    pub fn AdbcStatementGetOptionDouble(
        statement: *mut AdbcStatement,
        key: *const ::std::os::raw::c_char,
        value: *mut f64,
        error: *mut AdbcError,
    ) -> AdbcStatusCode;
}
extern "C" {
    /**Get the schema for bound parameters.

 This retrieves an Arrow schema describing the number, names, and
 types of the parameters in a parameterized statement. The fields
 of the schema should be in order of the ordinal position of the
 parameters; named parameters should appear only once.

 If the parameter does not have a name, or the name cannot be
 determined, the name of the corresponding field in the schema will
 be an empty string. If the type cannot be determined, the type of
 the corresponding field will be NA (NullType).

 This should be called after AdbcStatementPrepare.

 # Returns

ADBC_STATUS_NOT_IMPLEMENTED if the schema cannot be determined.*/
    pub fn AdbcStatementGetParameterSchema(
        statement: *mut AdbcStatement,
        schema: *mut ArrowSchema,
        error: *mut AdbcError,
    ) -> AdbcStatusCode;
}
extern "C" {
    /**Set a string option on a statement.
 # Arguments

* `statement` (direction in) - The statement.
 * `key` (direction in) - The option to set.
 * `value` (direction in) - The option value.
 * `error` (direction out) - An optional location to return an error
 message if necessary.
 # Returns

ADBC_STATUS_NOT_IMPLEMENTED if the option is not recognized.*/
    pub fn AdbcStatementSetOption(
        statement: *mut AdbcStatement,
        key: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
        error: *mut AdbcError,
    ) -> AdbcStatusCode;
}
extern "C" {
    /**Set a bytestring option on a statement.

 > Available since: ADBC API revision 1.1.0
 # Arguments

* `statement` (direction in) - The statement.
 * `key` (direction in) - The option to set.
 * `value` (direction in) - The option value.
 * `length` (direction in) - The option value length.
 * `error` (direction out) - An optional location to return an error
 message if necessary.
 # Returns

ADBC_STATUS_NOT_IMPLEMENTED if the option is not recognized*/
    pub fn AdbcStatementSetOptionBytes(
        statement: *mut AdbcStatement,
        key: *const ::std::os::raw::c_char,
        value: *const u8,
        length: usize,
        error: *mut AdbcError,
    ) -> AdbcStatusCode;
}
extern "C" {
    /**Set an integer option on a statement.

 > Available since: ADBC API revision 1.1.0
 # Arguments

* `statement` (direction in) - The statement.
 * `key` (direction in) - The option to set.
 * `value` (direction in) - The option value.
 * `error` (direction out) - An optional location to return an error
 message if necessary.
 # Returns

ADBC_STATUS_NOT_IMPLEMENTED if the option is not recognized*/
    pub fn AdbcStatementSetOptionInt(
        statement: *mut AdbcStatement,
        key: *const ::std::os::raw::c_char,
        value: i64,
        error: *mut AdbcError,
    ) -> AdbcStatusCode;
}
extern "C" {
    /**Set a double option on a statement.

 > Available since: ADBC API revision 1.1.0
 # Arguments

* `statement` (direction in) - The statement.
 * `key` (direction in) - The option to set.
 * `value` (direction in) - The option value.
 * `error` (direction out) - An optional location to return an error
 message if necessary.
 # Returns

ADBC_STATUS_NOT_IMPLEMENTED if the option is not recognized*/
    pub fn AdbcStatementSetOptionDouble(
        statement: *mut AdbcStatement,
        key: *const ::std::os::raw::c_char,
        value: f64,
        error: *mut AdbcError,
    ) -> AdbcStatusCode;
}
extern "C" {
    /**Execute a statement and get the results as a partitioned
 result set.

 # Arguments

* `statement` (direction in) - The statement to execute.
 * `schema` (direction out) - The schema of the result set.
 * `partitions` (direction out) - The result partitions.
 * `rows_affected` (direction out) - The number of rows affected if known,
 else -1. Pass NULL if the client does not want this information.
 * `error` (direction out) - An optional location to return an error
 message if necessary.
 # Returns

ADBC_STATUS_NOT_IMPLEMENTED if the driver does not support
 partitioned results*/
    pub fn AdbcStatementExecutePartitions(
        statement: *mut AdbcStatement,
        schema: *mut ArrowSchema,
        partitions: *mut AdbcPartitions,
        rows_affected: *mut i64,
        error: *mut AdbcError,
    ) -> AdbcStatusCode;
}
/**Common entry point for drivers via the driver manager
 (which uses dlopen(3)/LoadLibrary). The driver manager is told
 to load a library and call a function of this type to load the
 driver.

 Although drivers may choose any name for this function, the
 recommended name is "AdbcDriverInit", or a name derived from the
 name of the driver's shared library as follows: remove the 'lib'
 prefix (on Unix systems) and all file extensions, then PascalCase
 the driver name, append Init, and prepend Adbc (if not already
 there). For example:

 - libadbc_driver_sqlite.so.2.0.0 -> AdbcDriverSqliteInit
 - adbc_driver_sqlite.dll -> AdbcDriverSqliteInit
 - proprietary_driver.dll -> AdbcProprietaryDriverInit

 # Arguments

* `version` (direction in) - The ADBC revision to attempt to initialize (see
 ADBC_VERSION_1_0_0).
 * `driver` (direction out) - The table of function pointers to
 initialize. Should be a pointer to the appropriate struct for
 the given version (see the documentation for the version).
 * `error` (direction out) - An optional location to return an error message
 if necessary.
 # Returns

ADBC_STATUS_OK if the driver was initialized, or
 ADBC_STATUS_NOT_IMPLEMENTED if the version is not supported. In
 that case, clients may retry with a different version.*/
pub type AdbcDriverInitFunc = ::std::option::Option<
    unsafe extern "C" fn(
        version: ::std::os::raw::c_int,
        driver: *mut ::std::os::raw::c_void,
        error: *mut AdbcError,
    ) -> AdbcStatusCode,
>;
